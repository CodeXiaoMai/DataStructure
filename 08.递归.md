# 递归 #

> 一个函数直接或间接调用自己

## 函数的调用 ##

- 当一个函数的运行期间调用另一个函数是，在运行被调函数之前，系统要完成三件事：
	
	1.	将所有的实际参数，返回地址（下一个要执行的语句的地址）等信息传递给被调函数保存
	2.	为被调函数的局部变量（也包括形参）分配空间
	3.	将控制转移到被调函数的入口
- 从被调函数返回到主调函数之前，系统也要完成三件事
	1.	保存被调函数的返回结果
	2.	释放被调函数所占的存储空间
	3.	依照被调函数保存的返回地址将控制转移到调用函数
- 当有多个函数相互调用时，按照“后调用先返回”的原则，上述函数之间信息传递和控制转移必须借助“栈”来实现，即系统将整个程序运行时所需的数据空间安排在一个酷，每当调用一个函数时，就在栈顶分配一个存储区，进行压栈操作，每当一个函数退出时，就释放它的存储区，进行出栈操作，当前运行的函数永远都在栈顶位置。

## 递归和循环 ##

递归：
	- 易于理解
	- 速度慢
	- 存储空间在
循环：
	- 不易理解
	- 速度快
	- 存储空间小
  
## 阶乘 ##
    # include <stdio.h>
    
    long f (long n) {
    	if (1 == n || 0 == n) {
    		return 1L;
    	}
    	return n * f(n - 1);
    }
    
    void main () {
    	int val;
    	int i;
    
    	while (true) {
    		printf("请输入一个数字\n");
    		scanf("%d", &val);
    		printf("%d的阶乘是:%d\n", val, f(val));
    	}
    	return;
    }

## 求和 ##

    # include <stdio.h>
    
    long sum (long n) {
    	if (1 == n) {
    		return 1L;
    	}
    	return n + sum(n - 1);
    }
    
    void main () {
    	int val;
    
    	while (true) {
    		printf("请输入一个数字\n");
    		scanf("%d", &val);
    		printf("1到%d的和是:%ld\n", val, sum(val));
    	}
    	return;
    }

## 汉诺塔 ##

有三根杆子A，B，C。A杆上有N个(N>1)穿孔圆盘，盘的尺寸由下到上依次变小。要求按下列规则将所有圆盘移至C杆：
每次只能移动一个圆盘；
大盘不能叠在小盘上面。
提示：可将圆盘临时置于B杆，也可将从A杆移出的圆盘重新移回A杆，但都必须遵循上述两条规则。
问：如何移？最少要移动多少次？

    # include <stdio.h>
    
    /**
     * 先把A柱子上的前n-1个盘子借助C移动到B
     * 将A柱子上的第n个盘子直接移动到C
     * 将B柱子上的n-1个盘子借助A移动到C
     */
    
    void hannuota (int n, char a, char b, char c) {
    	if (1 == n) {
    		// 如果只有一个盘子，直接从a移动到c
    		printf("将编号为%d的盘子直接从%c移动到%c\n", n, a, c);
    		return;
    	} else {
    		/* 先将a中的前n - 1 个盘子借助c移动到b
    		 * 直接将a中的第n个盘子移动到c
    		 * 将b中的n-1个盘子借助a移动到c
    		 */
    		hannuota(n - 1, a, c, b);
    		printf("将编号为%d的盘子直接从%c移动到%c\n", n, a, c);
    		hannuota(n - 1, b, a, c);
    		return;
    	}
    }
    
    void main() {
    	char ch1 = 'A';
    	char ch2 = 'B';
    	char ch3 = 'C';
    	int n;
    
    	printf("请输入要移动盘子的个数\n");
    	scanf("%d", &n);
    	hannuota(n, ch1, ch2, ch3);
    	return;
    }

## 递归的应用 ##

树和森林就是以递归的方式定义的

树和图的很多算法就是以递归来实现的

很多数学公式以递归的方式定义:

- 斐波拉契序列